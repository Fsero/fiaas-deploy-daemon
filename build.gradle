import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:3.0.5'
        classpath 'com.tkruse.gradle:gradle-groovysh-plugin:1.0.7'
        gradleApi()
    }
}

repositories {
    mavenCentral()
}

apply plugin: 'com.bmuschko.docker-remote-api'
apply plugin: 'com.github.tkruse.groovysh'
apply plugin: 'maven-publish'
apply plugin: 'publishing'

apply from: "$rootDir/gradle/python.gradle"
apply from: "$rootDir/gradle/idea.gradle"

/*****************
 * Set project details
 */

description = 'fiaas-deploy-daemon'
group = 'no.finntech'
version = getDate()

/*****************
 * Configure publishing for fiaas-artifact
 */

publishing {
    publications {
        fiaas(MavenPublication) {
            artifact('fiaas.yml') {
                classifier 'fiaas'
            }
            groupId = 'no.finntech'
            artifactId = 'fiaas-deploy-daemon'
            version = '1.0-SNAPSHOT'
        }
    }

    repositories {
        maven {
            url 'https://mavenproxy.finntech.no/finntech-internal-snapshot/'
        }
    }
}

/*****************
 * Docker tasks
 */

docker {
    if (System.env.DOCKER_HOST) {
        url = "$System.env.DOCKER_HOST".replace("tcp", "https")
        if (System.env.DOCKER_CERT_PATH) {
            certPath = new File(System.env.DOCKER_CERT_PATH)
        }
    } else {
        url = 'unix:///var/run/docker.sock'
    }
}

def image_name = "containers.schibsted.io/finntech/${project.description}"
def image_tag = "${image_name}:${project.version}-${getGitHash()}"

task bakeImage(type: DockerBuildImage) {
    description 'Build docker image'
    dependsOn build
    inputs.file 'Dockerfile'
    inputs.files build.outputs
    inputDir projectDir
    tag image_tag
}

task tagLatestImage(type: DockerTagImage) {
    dependsOn bakeImage
    force = true
    repository image_name
    targetImageId { bakeImage.getImageId() }
    tag "latest"
}

// Ideally we would use DockerPushImage here, but it doesn't support reading the docker config,
// or even authenticating with a token. So, we have to fall back to executing the docker client.
task publishImage(type: Exec) {
    description 'Publish docker image to docker registry'
    group 'publishing'
    dependsOn bakeImage
    executable = 'docker'
    args = ['push', image_tag]
    doLast {
        logger.lifecycle("Pushed image ${image_tag}")
    }
}
task publishLatestImage(type: Exec) {
    description 'Publish "latest" docker image to docker registry'
    group 'publishing'
    dependsOn tagLatestImage
    executable = 'docker'
    args = ['push', "${image_name}:latest"]
    doLast {
        logger.lifecycle("Pushed image ${image_name}:latest")
    }
}
publish.dependsOn(publishImage)
publish.dependsOn(publishLatestImage)

/*****************
 * Misc tasks
 */

task clean(type: Delete) {
    delete fileTree(dir: 'fiaas_deploy_daemon', include: '**/*.pyc')
    delete fileTree(dir: 'k8s', include: '**/*.pyc')
    delete fileTree(dir: 'tests', include: '**/*.pyc')
    delete build.outputs
    delete test.outputs
}


task wrapper(type: Wrapper) {
    gradleVersion = '3.1'
}

/*****************
 * Helpers
 */

def getDate() {
    def date = new Date()
    def formattedDate = date.format('yyyyMMddHHmmss')
    return formattedDate
}

def getGitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}
